# Lab3 PSO materials

</br>
</br>

Index

1. handout go through
1. in memory file system
1. interrupt and function arguments
1. asm function, inline asm 
1. caller callee convention
1. return values
1. elf system



</br>
</br>
</br>
</br>

------------------------------------------
</br>

</br>
</br>

### 0. Project setup
1. Accept the project [CLICK Github Classroom Lab3 Link]();
2. [Read the Lab3 handout](https://www.cs.purdue.edu/homes/pfonseca/teaching/cs503/21spring/labs/lab3.html) multiple times before start.


</br>
</br>
</br>
</br>
</br>

</br>
</br>

------------------------------------------
</br>



### 1. Handout

</br>

- Basic in-memory file system (30pt)

* `syscall fileregister(char *path, char *file, int file_size)`
* `char* fileopen(char *path, int *file_size_out)`
* `syscall fileclose(char *path)`
* `syscall filelist(char *buf_list_out, int buf_list_max)`
* `syscall fileunregister(char *path)`

</br>

- Implement a system call interface based on software interrupts (30 pts)

  Instead of directly call system function, we use a uniform interface function trigger a software interrupt. And let the interrupt service function do the actual system function based on the input arguments. 

</br>


- Create a new system call that dynamically loads a program (60 pts)
 Parse the elf files, set memory and fill in the *load_data* with details.

 
</br>
</br>
</br>
</br>

</br>
</br>

------------------------------------------
</br>
</br>
</br>


### 2. In memory file system

* memory.h
* getmem.c
* freemem.c

linklist, semaphore

</br>

* How does XINU implment memory system's link list?

* How to implement a link list for general purpose?

```plain-text
struct Node {                                  |    struct Node {
    int val;                                   |        int val;
    struct Node* nxt;                          |        struct Node* nxt;
};                                             |    }
                                               |    
struct Node* n1 = new struct Node();           |    struct Node* n1 = getmem( sizeof(struct Node) );
struct Node* n2 = new struct Node();           |    struct Node* n2 = getmem( sizeof(struct Node) );
                                               |    
n1->nxt = n2;                                  |    n1->nxt = n2;
```




</br>
</br>
</br>

------------------------------------------
</br>
</br>
</br>

### 3. Interrupt system and Function argument
</br>
</br>
</br>
</br>

#### 3.1 What is software interrupt. And difference with the function call?

*Software interrupt* is generated by the software '`int`' instruction. i.e. the famous linux x86 system system call reserves `0x80` interrupt.  

`asm("int $0x80")`

</br>

When a (software) interrupt raise, the cpu would **push** the current contents of the `EFLAGS`, `CS`, and `EIP` registers on the stack and jump to the relative interrupt service routine (**ISR**) according to the **IDT** (interrupt descript table).

</br>
</br>
</br>
</br>
</br>
</br>


</br>
</br>


For this lab3, as well as for linux, when making a system function call, we trigger a *0x80* software interrupt. And let its *ISR* to performance the actual system function for us.


There are 2 issues we need to figuer out before we trigger `int 0x80`.
1. How to configuer a *IRS* to *0x80* in a *IDT*.?
2. How a IRS know which system call needed.


</br>
</br>
</br>
</br>
</br>
</br>

#### 3.2  How to configuer a IRS to 0x80 in a IDT (issue 1).

read 'evec.c' and 'intra.S'.


</br>

IDT table, defined in 'start.S' and declarationed in 'evec.c'. 
```c
extern	struct	idt idt[NID];	/* Interrupt descriptor table		*/
```

</br>

Connect a ISR to a interrupt
```c
int32	set_evec(uint32 xnum, uint32 handler) {
    ... 
    pidt = &idt[xnum];
    pidt->igd_loffset = handler;
    ...
}
```

</br>
</br>

```c
int32	initevec() {
        ...
	for(i = 0; i < NID; i++) {
		set_evec(i, defevec[i]);
	}
        ...
}
```

</br>

The `defevec` table in 'intr.S'
```asm
	.globl	defevec
defevec:
	.long	_Xint0			/* Divide error			*/
	.long	_Xint1			/* Debug exceptions		*/
	.long	_Xint2			/* Nonmaskable interrupt	*/
        ...
```

</br>
</br>

A example of default XINU interrup service function. 

```asm
# intr.S
	.globl	_Xint0			/* Divide error			*/
_Xint0:
	pushal
	movl	%esp, %eax
	pushl	%eax
	pushl	$0
	jmp	Xtrap

```

p.s. Xtrap will call the "famous" c trap function which defined in 'evec.c'



In all, to connect `0x80` to interrupt service function, we need
```asm
# mXint0x80.S
    .globl mXint0x80  
mXint0x80:
    // TODO: implement the "small assembly routine" here.

    iret
```

Link the service function to the interrupt.
```c
// initialize.c
    ...
    set_evec(0x80, (uint32)mXint0x80);
    ...
```



#### 3.3  How a IRS know which system call needed (issue 2).


</br>
</br>

Function call case:
```asm
fun1: 
    pushl %ebp
    movl %esp, %ebp
    
    movl 8(%ebp), %eax   
    addl 12(%ebp), %eax  # 3 + 5

    movl %ebp, %esp
    pop %ebp
    ret 
```
```c
int main(){
   ..
   fun1(3,5);
   ..
}
```



ebp points to main's stack base.
esp points to main's stack top.
```
|--------|  0x00FFFF
|--------|
|--------| 
|        |
|--------|  <--- ebp (main) 
|        |  
|--------|  <--- esp (main)
|        |
|--------| 
|        |
|--------| 
|--------|   0x00FF00
|--------|
```


after `pushl 5`

```
|--------|  0x00FFFF
|--------|
|        |
|--------|  <--- ebp (main) 
|        |  
|--------|  
|   5    |  <--- esp 
|--------| 
|        |
|--------| 
|--------|   0x00FF00
|--------|
```

after `push 3`




```
|--------|  0x00FFFF
|--------|
|        |
|--------|  <--- ebp (main)   //0x00FF45
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef| 
|0x00ff45|
|        | 
|--------|   0x00FF00
|--------|
```




```asm

main: 
   pushl $5
   pushl $3
   call fun1. // push the eip, jmp to fun1
   ret    // pop the eip from the stack top

```

```
xxx
xxx
0x0014 :
0x0010 :   x
0x000c :   5
0x0008 :   3
0x0004 :  0xabcdef
0x0000 :
```
</br>
</br>
</br>
</br>

Interrupt case:
```
int fun(int a1, int a2){
  int y=a1+a2;
  return y;
}

int main(){
   int x=0;
   x++;
   // an interrupt happens here. i.e. asm("int $0x80");
   x=5;
   return;
}

```


```asm

main: 
   pushl $5
   pushl $3
   int %0x80 // push flag, push the eip, jmp to fun1
   ret    // pop the eip from the stack top

```

```
xxx
xxx
0x0014 :
0x0010 :   x
0x000c :   5
0x0008 :   3
0x0004 :  Flag-xxxxxx
0x0000 :  0xabcdef

```

```




</br>
</br>
</br>



------------------------------------------
</br>
</br>
</br>


### 4. asm function, inline asm 

some examples.
ctxsw.S
syscall_interface.c

</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>

### 5. caller callee convention


</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>

### 6. return values


</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>

### 7. elf system


</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>



