# Lab3 PSO materials

</br>
</br>

Index

1. handout go through
1. in memory file system
1. interrupt and function arguments
1. asm function, inline asm 
1. caller callee convention
1. return values
1. elf system



</br>
</br>
</br>
</br>

------------------------------------------
</br>

</br>
</br>

### 0. Project setup
1. Accept the project [CLICK Github Classroom Lab3 Link]();
2. [Read the Lab3 handout](https://www.cs.purdue.edu/homes/pfonseca/teaching/cs503/21spring/labs/lab3.html) multiple times before start.


</br>
</br>
</br>
</br>
</br>

</br>
</br>

------------------------------------------
</br>



### 1. Handout

</br>

- Basic in-memory file system (30pt)

* `syscall fileregister(char *path, char *file, int file_size)`
* `char* fileopen(char *path, int *file_size_out)`
* `syscall fileclose(char *path)`
* `syscall filelist(char *buf_list_out, int buf_list_max)`
* `syscall fileunregister(char *path)`

</br>

- Implement a system call interface based on software interrupts (30 pts)

  Instead of directly call system function, we use a uniform interface function trigger a software interrupt. And let the interrupt service function do the actual system function based on the input arguments. 

</br>


- Create a new system call that dynamically loads a program (60 pts)
 Parse the elf files, set memory and fill in the *load_data* with details.

 
</br>
</br>
</br>
</br>

</br>
</br>

------------------------------------------
</br>
</br>
</br>


### 2. Memory system

* memory.h
* getmem.c
* freemem.c

```
// at very begining
0x0                                        0xffffffff
|------------------------------------------------|
|                                                |
|------------------------------------------------|

// allocate memory 
     x                         f
|------------------|-----------------------------|
|                  |                             |
|------------------|-----------------------------|


// free memory
    f           x               f  
|------------|-----|------------------------------|
|            |     |                              |
|------------|-----|------------------------------|

^     ^      ^     ^           ^                  ^
beg   len   end    beg        len               end
```

</br>
</br>

```c
// memory.h
struct	memblk	{			
	struct	memblk	*mnext;		/* Ptr to next free memory blk	*/
	uint32	mlength;		/* Size of blk (includes memblk)*/
};
```

</br>

A trival thing about 
* getstk
* freestk

</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>


For lab3  
**[Q]**  How to implement a link list for general purpose?

```plain-text
struct Node {                                  |    struct Node {
    int val;                                   |        int val;
    struct Node* nxt;                          |        struct Node* nxt;
};                                             |    }
                                               |    
struct Node* n1 = new struct Node();           |    struct Node* n1 = getmem( sizeof(struct Node) );
struct Node* n2 = new struct Node();           |    struct Node* n2 = getmem( sizeof(struct Node) );
                                               |    
n1->nxt = n2;                                  |    n1->nxt = n2;
```

</br>
</br>
</br>

**[Q]** do we need to use semaphar?  
It is not necessaray. And depend on your design.


</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

------------------------------------------
</br>
</br>
</br>

### 3. Interrupt system and argument in stack
</br>
</br>
</br>
</br>

#### 3.1 What is software interrupt. And difference with the function call?

*Software interrupt* is generated by the software '`int`' instruction. i.e. the famous linux x86 system system call reserves `0x80` interrupt.  

`asm("int $0x80")`

</br>

When a (software) interrupt raise, the cpu would **push** the current contents of the `EFLAGS`, `CS`, and `EIP` registers on the stack and jump to the relative interrupt service routine (**ISR**) according to the **IDT** (interrupt descript table).

</br>
</br>
</br>
</br>
</br>
</br>


</br>
</br>


For this lab3, as well as for linux, when making a system function call, we trigger a *0x80* software interrupt. And let its *ISR* to performance the actual system function for us.


There are 2 issues we need to figuer out before we trigger `int 0x80`.
1. How to configuer a *IRS* to *0x80* in a *IDT*.?
2. How a IRS know which system call needed.


</br>
</br>
</br>
</br>
</br>
</br>

#### 3.2  How to configuer a IRS to 0x80 in a IDT (issue 1).

read 'evec.c' and 'intra.S'.


</br>

IDT table, defined in 'start.S' and declarationed in 'evec.c'. 
```c
extern	struct	idt idt[NID];	/* Interrupt descriptor table		*/
```

</br>

Connect a ISR to a interrupt
```c
int32	set_evec(uint32 xnum, uint32 handler) {
    ... 
    pidt = &idt[xnum];
    pidt->igd_loffset = handler;
    ...
}
```

</br>
</br>

```c
int32	initevec() {
        ...
	for(i = 0; i < NID; i++) {
		set_evec(i, defevec[i]);
	}
        ...
}
```

</br>

The `defevec` table in 'intr.S'
```asm
	.globl	defevec
defevec:
	.long	_Xint0			/* Divide error			*/
	.long	_Xint1			/* Debug exceptions		*/
	.long	_Xint2			/* Nonmaskable interrupt	*/
        ...
```

</br>
</br>

A example of default XINU interrup service function. 

```asm
# intr.S
	.globl	_Xint0			/* Divide error			*/
_Xint0:
	pushal
	movl	%esp, %eax
	pushl	%eax
	pushl	$0
	jmp	Xtrap

```

p.s. Xtrap will call the "famous" c trap function which defined in 'evec.c'



In all, to connect `0x80` to interrupt service function, we need
```asm
# mXint0x80.S
    .globl mXint0x80  
mXint0x80:
    // TODO: implement the "small assembly routine" here.

    iret
```

Link the service function to the interrupt.
```c
// initialize.c
    ...
    set_evec(0x80, (uint32)mXint0x80);
    ...
```



#### 3.3  How a IRS know which system call needed (issue 2).


</br>
</br>

Function call case:
```asm
fun1: 
    pushl %ebp
    movl %esp, %ebp
    
    movl 8(%ebp), %eax   
    addl 12(%ebp), %eax  # 3 + 5

    # ...

    movl %ebp, %esp
    pop %ebp
    ret 
```

```c
int main(){        |  main:
   ..              |     .. 
   fun1(3,5);      |     pushl 5
                   |     pushl 3
                   |     call fun1
   ..              |     ..
}                  |     ret
```



ebp points to main's stack base.
esp points to main's stack top.
```
   ...
|--------|  0x00FFFF
|        |
|--------|  <-- ebp   //0x00FF48   (main stk base)
|        |  
|--------|  <-- esp 
|        |
|        |
|--------|  0x00FF00
    ...
```


 `pushl 5`

```
|--------|  0x00FFFF
|        |
|--------|  <--- ebp   //0x00FF48 (main stk base)
|        |  
|--------|  
|   5    |  <--- esp 
|        |
|        |
|--------|  0x00FF00
```

 `push 3`

```
|--------|  0x00FFFF
|        |
|--------|  <--- ebp   //0x00FF48 (main stk base)
|        |  
|--------|
|   5    | 
|   3    |  <--- esp 
|        |
|--------|  0x00FF00
```

 `call fun1`

```
|--------|  0x00FFFF
|        |
|--------|  <--- ebp   //0x00FF48 (main stk base)   
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef|  <--- esp   //0x00FF28
|        |
|        | 
|--------|   0x00FF00
```

`push %ebp`

```
|--------|  0x00FFFF
|        |
|--------|  <--- ebp   //0x00FF48 (main stk base) 
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef|             //0x00FF28
|0x00ff48|  <--- esp   //0x00FF24     
|        |              
|        |             
|--------|   0x00FF00
```

`movl %esp, %ebp`

```
|--------|  0x00FFFF
|        |
|--------|              //0x00FF48 (main stk base)
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef|              //0x00FF28
|0x00ff48|  <--esp, ebp //0x00FF24 (fun1 stk base)   
|        |              
|        |              
|--------|   0x00FF00
```

assume afte `fun1` runs a while.

```
|--------|  0x00FFFF
|        |
|--------|              //0x00FF48
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef|              //0x00FF28
|0x00ff48|  <-- ebp     //0x00FF24     
|   ...  |
|        |  <-- esp                      
|        |   
|--------|  0x00FF00
```


`movl %ebp, %esp`

```
|--------|  0x00FFFF
|        |
|--------|              //0x00FF48
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef|              //0x00FF28
|0x00ff48|  <-- ebp,esp //0x00FF24     
|        |
|        |  
|--------|  0x00FF00
```


`pop %ebp`

```
|--------|  0x00FFFF
|        |
|--------|  <-- ebp     //0x00FF48
|        |  
|--------|  
|   5    | 
|   3    | 
|0xabcdef|  <-- esp     //0x00FF28
|        |       
|        |  
|--------|  0x00FF00
```

`ret`

```
|--------|  0x00FFFF
|        |
|--------|  <-- ebp     //0x00FF48
|        |  
|--------|  
|   5    | 
|   3    |  <-- esp
|        |       
|        |  
|--------|  0x00FF00
```


</br>
</br>
</br>
</br>

Interrupt case:
```
_Xint0:
    pushl %ebp
    movl  %esp, %ebp
    ..
    movl  %ebp, %esp
    popl  %ebp
    iret

int main(){
   ..
   x/0;  // or asm("int 0");    
   ..
   return;
}

```


```
   ...
|--------|  0x00FFFF
|        |
|--------|  <-- ebp   //0x00FF48   (main stk base)
|        |  
|--------|  <-- esp 
|        |
|        |
|--------|  0x00FF00
    ...
```


 `x/0` to `_Xint0`

```
|--------|  0x00FFFF
|        |
|--------|  <--- ebp  //0x00FF48 (main stk base)   
|        |  
|--------| 
|  EFLAG | 
|  CS    |
|0xabcdef|  <--- esp  //0x00FF28
|        |
|        | 
|--------|   0x00FF00
```

`pusb %ebp`

```
|--------|  0x00FFFF
|        |
|--------|  <--- ebp   //0x00FF48 (main stk base) 
|        |  
|--------|  
|  EFLAG | 
|  CS    | 
|0xabcdef|             //0x00FF28
|0x00ff48|  <--- esp   //0x00FF24     
|        |              
|        |             
|--------|   0x00FF00
```

`movl %esp, %ebp`

```
|--------|  0x00FFFF
|        |
|--------|              //0x00FF48 (main stk base)
|        |  
|--------|  
|  EFLAG | 
|  CS    | 
|0xabcdef|              //0x00FF28
|0x00ff48|  <--esp, ebp //0x00FF24 (_Xin0 stk base)   
|        |              
|        |              
|--------|   0x00FF00
```



[Q] How to get the first argument if there is any?



before `_Xint0` return.

```
|--------|  0x00FFFF
|        |
|--------|              //0x00FF48 (main stk)
|        |  
|--------|  
|  EFLAG | 
|  CS    | 
|0xabcdef|              //0x00FF28
|0x00ff48|  <-- ebp     //0x00FF24 (_Xint0 stk)    
|   ...  |
|        |  <-- esp                      
|        |   
|--------|  0x00FF00
```


`movl %ebp, %esp`

```
|--------|  0x00FFFF
|        |
|--------|              //0x00FF48 (Main stk)
|        |  
|--------|  
|  EFLAG | 
|  CS    | 
|0xabcdef|              //0x00FF28
|0x00ff48|  <-- ebp,esp //0x00FF24 (Xint0 stk)     
|        | 
|        |  
|--------|  0x00FF00
```


`pop %ebp`

```
|--------|  0x00FFFF
|        |
|--------|  <-- ebp     //0x00FF48 (main stk)
|        |  
|--------|  
|  EFLAG | 
|  CS    | 
|0xabcdef|  <-- esp     //0x00FF28 (return address)
|        |       
|        |  
|--------|  0x00FF00
```

`iret`

```
|--------|  0x00FFFF
|        |
|--------|  <-- ebp     //0x00FF48 (main stk)
|        |  
|--------|  <-- esp
|        |       
|        |  
|--------|  0x00FF00
```





</br>
</br>
</br>


------------------------------------------
</br>
</br>
</br>


### 4. asm function, inline asm 

some examples.
1. ctxsw.S
2. syscall_interface.c

`pushal` and `popal` push and pop the following 8 registers on and from the stack.
"EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI"


```c
//syscall_interface.c
	
	orinargs = nargs;
	args = (int *)(&nargs +1);

	args = args + 5  - 1;
	
	//push five arguments and number of nargs to stack
	//Note that the address of argument in your handler function may not be exactly same as the address being "pushed" here
	//You may want to print the address of esp to understand where these data are stored on the stack
	asm(
	    "movl %1,%%eax;"
            "pushl %%eax;"
	    "movl %2,%%eax;"
            "pushl %%eax;"
            "movl %3,%%eax;"
            "pushl %%eax;"
            "movl %4,%%eax;"
            "pushl %%eax;"
            "movl %5,%%eax;"
            "pushl %%eax;"
	    "movl %6, %%eax;"
	    "pushl %%eax;"
	    "int $0x80;"
	    "movl %%eax, %0;"
	    "popl %%eax;"
	    "popl %%eax;"
       	    "popl %%eax;"
            "popl %%eax;"
            "popl %%eax;"
            "popl %%eax;"
	    : "=r"(retval)
	    :"g"(*args), "g"(*(args-1)),"g"(*(args-2)),"g"(*(args-3)),"g"(*(args-4)),"g" (orinargs)
	    : "%eax"
	   );

	return retval;

```


</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>

### 5. caller callee convention
in human language:  
"
A convention that some registers callee can directly use (modify, dirty) without backup-ahead-restore-before-ret. While some of the registers callee must make sure when return, the value is remain the same. 

With that convention, the caller knows he need to back up some of the registers that callee might use. And knows that some registers values might be changed after a function call. "
</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>

### 6. Return values

eax store the integer returned values.

</br>
</br>
</br>

</br>
</br>
</br>

</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>

### 7. elf system
Materials need to read
* [How To Write Shared Libraries](https://akkadia.org/drepper/dsohowto.pdf)”
* [Essays on loaders and linkers by Lance Taylor](http://a3f.at/lists/linkers)”
* [ELF hello world](https://cirosantilli.com/elf-hello-world)
* [ELF format specification](https://refspecs.linuxbase.org/elf/elf.pdf)

* sample_loader.c

<!--
```c
void *image_load (char *elf_start, unsigned int size)
{
    Elf32_Ehdr      *hdr     = NULL;
    Elf32_Phdr      *phdr    = NULL;
    Elf32_Shdr      *shdr    = NULL;
    Elf32_Sym       *syms    = NULL;
    char            *strings = NULL;
    char            *start   = NULL;
    char            *taddr   = NULL;
    void            *entry   = NULL;
    int i = 0;
    char *exec = NULL;
    hdr = (Elf32_Ehdr *) elf_start;
    if(!is_image_valid(hdr)) {
        printk("image_load:: invalid ELF image\n");
        return 0;
    }
    exec = mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC,
                      MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if(!exec) {
        printk("image_load:: error allocating memory\n");
        return 0;
    }
    // Start with clean memory.
    memset(exec,0x0,size);
    phdr = (Elf32_Phdr *)(elf_start + hdr->e_phoff);
    for(i=0; i < hdr->e_phnum; ++i) {
            if(phdr[i].p_type != PT_LOAD) {
                    continue;
            }
            if(phdr[i].p_filesz > phdr[i].p_memsz) {
                    printk("image_load:: p_filesz > p_memsz\n");
                    munmap(exec, size);
                    return 0;
            }
            if(!phdr[i].p_filesz) {
                    continue;
            }
            // p_filesz can be smaller than p_memsz,
            // the difference is zeroe'd out.
            start = elf_start + phdr[i].p_offset;
            taddr = phdr[i].p_vaddr + exec;
            memmove(taddr,start,phdr[i].p_filesz);
            if(!(phdr[i].p_flags & PF_W)) {
                    // Read-only.
                    mprotect((unsigned char *) taddr,
                              phdr[i].p_memsz,
                              PROT_READ);
            }
            if(phdr[i].p_flags & PF_X) {
                    // Executable.
                    mprotect((unsigned char *) taddr,
                            phdr[i].p_memsz,
                            PROT_EXEC);
            }
    }
    shdr = (Elf32_Shdr *)(elf_start + hdr->e_shoff);
    for(i=0; i < hdr->e_shnum; ++i) {
        if (shdr[i].sh_type == SHT_DYNSYM) {
            syms = (Elf32_Sym*)(elf_start + shdr[i].sh_offset);
            strings = elf_start + shdr[shdr[i].sh_link].sh_offset;
            entry = find_sym("main", shdr + i, strings, elf_start, exec);
            break;
        }
    }
    for(i=0; i < hdr->e_shnum; ++i) {
        if (shdr[i].sh_type == SHT_REL) {
            relocate(shdr + i, syms, strings, elf_start, exec);
        }
    }
   return entry;
}// image_load 

```

-->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>




------------------------------------------
</br>
</br>
</br>




### Generate the elf files

**[Q]** How to transer my own hello.c to elf form?

```gcc -m32 -march=i586 -fno-builtin -fPIE -pie -fno-stack-protector -Wall -nostdlib -z max-page-size=4096 -O0 -DBSDURG -o ./hello.elf ./hello.c ./needed.o```


</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

------------------------------------------
</br>
</br>
</br>
</br>
</br>

Ex1:

1. kprintf the address that get from getmem



</br>
</br>
</br>
</br>
</br>
</br>

------------------------------------------
</br>
</br>
</br>
</br>
</br>

Ex2:


2.  print for debug


